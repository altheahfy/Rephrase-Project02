# Rephraseプロジェクト ランダマイズ・表示システム設計仕様書（2025年7月改訂版）

## 目的
Rephraseプロジェクトにおけるランダマイズ処理から表示までの統合的なデータフロー、各モジュールの役割分担、効率性を重視した設計理念を記述し、実装・引き継ぎ時の基準文書とする。

---

## 🎓 学習革命：無限パターンプラクティス環境

### 母国語非介入学習の実現
- **視覚主導学習**: イラスト表示と英語テキスト制御の組み合わせ
- **直接想起訓練**: 翻訳思考を介さない英語脳の構築
- **段階的負荷調整**: 学習者の習熟度に応じた適切な挑戦レベル

### 無限練習環境の教育的意義
- **パターンプラクティス革命**: 同一構文・多様表現による飽きのこない反復学習
- **コンテキスト多様化**: V_group_keyによる文法パターンの多角的練習
- **自動難易度調整**: 重複回避システムによる最適な学習体験

### 学習心理学的効果
- **変動比率強化**: ランダム性による高い学習動機維持
- **転移学習促進**: 多様なコンテキストでの応用力構築
- **自信構築**: 成功体験の積み重ねによる学習効力感向上
- **流暢性獲得**: 文法パターンの自動化による自然な英語表現力

### 認知負荷理論に基づく設計
- **本質的負荷**: 文法学習に集中するための環境整備
- **外在的負荷**: 不要な情報（母国語翻訳等）の排除
- **生成的負荷**: パターン認識とスキーマ構築の促進

---

## 🎲 **個別ランダマイズシステム仕様**

### **全体ランダマイズとの関係**
- **前提条件**: 全体ランダマイズ実行時に `window.fullSlotPool` を作成
- **データソース**: `window.fullSlotPool`（個別ランダマイズの母集団として利用）
- **実行主体**: `randomizer_individual.js` 内の各個別ランダマイズ関数

### **個別ランダマイズの実行フロー**
```
1. 個別ランダマイズ実行 → randomizer_individual.js
   └─ 例：randomizeSlotSIndividual(), randomizeSlotM1Individual() 等

2. 候補抽出・選択 → window.fullSlotPoolから該当スロット候補を抽出
   └─ 現在表示中のスロットを除外してランダム選出

3. データ更新 → window.lastSelectedSlotsを更新

4. 動的エリア更新 → buildStructure(window.lastSelectedSlots)呼び出し
   └─ structure_builder.js で動的記載エリア再構築

5. 静的エリア同期 → MutationObserverが動的エリア変更を検出
   └─ insert_test_data_clean.js でsafeJsonSync自動実行
```

### **安全性設計**
- **影響範囲制限**: 該当スロットのみに影響、他スロットは維持
- **既存機能保護**: 全体ランダマイズ機能に変更なし
- **エラーハンドリング**: 母集団データ不在時・候補不足時の適切な処理

---

## 🔧 **O1 表示特例仕様**
- **特例条件**: O1 に `Slot_display_order` が複数存在する場合（例：What do you think it is? の分離構造）
- **特例処理**: subslot を生成せず、slot-mark のみを出力データに含める
- **一般処理**: 上記以外の場合は、他のスロット同様に subslot データを出力対象に含める
- **実装責任**: ランダマイザーが判定・制御、Structure側は受け取ったデータをそのまま描画

---

## 📋 **開発・保守に関する重要事項**

### **デバッグ機能**
実装済みのデバッグ関数群：
- `window.checkFullSlotPool()`: 母集団データ確認
- `window.checkAllSSlotSources()`: 全データソース確認  
- `window.checkCurrentSelection()`: 現在選択データ確認

### **拡張性設計**
- **水平展開対応**: 個別ランダマイズパターンは他スロット（V, O, C等）への展開が可能
- **設定変更の局所化**: 表示ルール変更は主にinsert_test_data_clean.js内で完結
- **データ構造変更の影響最小化**: 候補提供と表示選択の分離により影響範囲を制限

### **学習・継承のポイント**
1. **段階的検証の重要性**: スモールステップアプローチによる安全な実装
2. **既存システム理解の必要性**: 同期関数名等の既存の仕組みを活用
3. **責任分離の利点**: 各モジュールが単一責任を持つことによる保守性向上
4. **データソース調査の必要性**: fullSlotPoolの構造等の実装前調査の重要性システム設計の基本思想**

### **柔軟性優先のアーキテクチャ**
- **データ提供者**と**表示担当者**の明確な責任分離
- 候補データの提供は事前に行い、実際の選択・表示は表示時に決定
- データ構造変更に対する柔軟な対応能力を確保

### **効率性の根拠**
1. **保守性**: 表示ルールの変更が局所化される（insert_test_data_clean.js）
2. **拡張性**: 新データが追加されても、表示ロジックのみの変更で対応可能
3. **責任分離**: 各モジュールが単一責任を持ち、相互依存を最小化

---

## 📊 **データフロー全体像**

### **実際のアーキテクチャ（検証済み）**

```
1. V_group_key選択・候補データ抽出
   └─ randomizer_all.js: V_group_keyを決定、該当する全候補をwindow.lastSelectedSlotsに格納（例：14個）

2. 動的記載エリアでの表示選択・レンダリング  
   └─ randomizer_individual.js: buildStructure(window.lastSelectedSlots)を呼び出し
   └─ structure_builder.js: 候補から実際の表示項目を選択し、動的記載エリアに描画（例：7個）

3. 静的スロットエリアとの同期
   └─ insert_test_data_clean.js: MutationObserverで動的記載エリアを監視
   └─ 変更検出時：safeJsonSync(window.loadedJsonData)を実行
   └─ 結果的に候補データ（14個）から同じ表示選択ロジックで静的スロットを更新
```

### **重要な設計判断：なぜこの方式なのか**

#### **従来型（事前選択方式）との比較**
- ❌ **事前選択方式**: randomizer → 選択済みデータ → 表示
- ✅ **現在方式**: randomizer → 全候補データ → 表示時選択

#### **現在方式の優位性**
1. **表示ロジックの柔軟性**: 画面サイズ、ユーザー設定等に応じた動的調整が可能
2. **データ構造の簡素化**: randomizer側で複雑な表示判定不要
3. **将来の拡張性**: 新しい表示条件追加時の影響範囲最小化

---

## 🔧 **各モジュールの詳細責任**

### **randomizer_all.js**
**役割**: 候補母集団の提供者
- V_group_key選択による候補データセット抽出
- `window.lastSelectedSlots`と`window.fullSlotPool`に候補データ格納
- **重要**: 選択ではなく候補提供が主責任

### **randomizer_individual.js** 
**役割**: 個別ランダマイズの制御
- `buildStructure(window.lastSelectedSlots)`呼び出し
- 特定スロットのみの再ランダマイズ制御
- 動的記載エリア更新のトリガー

### **structure_builder.js**
**役割**: 動的記載エリアでの実際の表示選択・レンダリング
- **核心機能**: `buildStructure(selectedSlots)`で候補データから表示項目を決定
- `upperSlots.forEach()`により最終的な表示選択を実行
- 動的記載エリア（dynamic-slot-area）への描画専任
- **編集禁止**: 動的記載エリアは他モジュールからの変更を禁止

### **insert_test_data_clean.js**
**役割**: 動的記載エリア→静的スロット同期システム
- **主要機能1**: MutationObserverによる動的記載エリア監視
- **主要機能2**: 変更検出時の`safeJsonSync(window.loadedJsonData)`実行
- **主要機能3**: 候補データから静的スロットへの同期処理
- **重要**: 独自選択ではなく、動的記載エリアとの同期が目的

---

## 🎯 **同期システムの詳細技術仕様**

### **動的記載エリア監視メカニズム**
```javascript
// MutationObserver設定（insert_test_data_clean.js）
const observer = new MutationObserver(function(mutations) {
  console.log("👀 動的記載エリアに変更を検出しました");
  
  if (window.syncDebounceTimer) {
    clearTimeout(window.syncDebounceTimer);
  }
  
  window.syncDebounceTimer = setTimeout(() => {
    console.log("🔄 変更検出による同期処理を実行します");
    if (window.loadedJsonData) {
      window.safeJsonSync(window.loadedJsonData);  // ← 候補データで同期
    }
  }, 300);
});
```

### **同期処理の核心ロジック**
1. **動的記載エリア変更検出** → MutationObserver発動
2. **デバウンス処理** → 300ms遅延で重複防止
3. **safeJsonSync実行** → `window.loadedJsonData`（候補データ）を使用
4. **同じ選択ロジック適用** → `syncUpperSlotsFromJson(data)`のforEachループ
5. **結果的な一致** → 動的記載エリアと静的スロットが100％一致

### **なぜ100％一致するのか**
- **同一の候補データソース**: 両方とも`window.loadedJsonData`を使用
- **同一の選択ロジック**: forEachループで最後の項目が選ばれる仕様
- **タイミング同期**: 動的記載エリア更新→即座に静的スロット同期

---

## 📝 **データ構造・母集団設計**

### **V_group_key 母集団の識別番号ランダマイズ仕様**
- V_group_key 母集団内のスロットは、例文IDを手掛かりに親スロットとサブスロットをペアとして整理
- 各スロットは、例文IDを超えた混合母集団形成のため「識別番号」を付与（例：M1-1, M1-2）
- ランダマイズは識別番号単位で行われ、選出された識別番号に対応する親スロットとそのサブスロットを一括で出力対象とする
- ExampleID は識別番号付与後のランダマイズ処理では使用せず、スロット種間の自然な混合を保証

### **DB構造との関係**
- DB (slot_order_data.json) は V_group_key 単位でスロット群を構造化
- 母集団キーは **構文ID + V_group_key (Aux＋V セット)**
- V_group_key は助動詞＋動詞の組を一意に示すもの
- 各スロットデータは V_group_key によってどの母集団に属するかが決まる

---

## 🚨 **重要な実装上の注意事項**

### **動的記載エリアの編集禁止原則**
- **絶対ルール**: `dynamic-slot-area`は読み取り専用
- **変更禁止**: DOM構造の変更、位置の移動、ラッパーへの移動すべて禁止
- **理由**: 他モジュールとの整合性確保、予期しない動作の防止

### **完全な表示更新の要件**
- **必須プロセス**: 動的記載エリア更新 + 静的スロット同期
- `structure_builder.js`のみでは不完全（静的エリア未更新）
- `insert_test_data_clean.js`の同期処理が必須

### **同期処理の技術的詳細**
- **完全リセット＋再構築方式**: 母集団間で異なるサブスロット構造に対応
- **display_order制御**: 例文による語順変更（O1先頭配置等）に必須
- **重複実行防止**: `window.isSyncInProgress`フラグによる制御
- **【重要】静的エリア同期の原則**:
  - 動的エリアは常に正解、絶対に変更禁止
  - 静的エリアは動的エリアとの完全同期が目標
  - 母集団間でサブスロット構造が異なる場合に対応するため完全リセット＋再構築方式を採用
- **display_order制御**: 例文による語順変更（O1先頭配置等）に必須
- randomizer_all.js が選択責任を持ち、構造モジュールは描画責任に集中。
- 個別ランダマイズボタン（🎲）は slot-container 内で SlotPhrase ラベルの横に配置し、slot-text 内には配置しない。
- **同期処理**: 個別ランダマイズでは `syncUpperSlotsFromJson()` と `syncSubslotsFromJson()` を使用。`syncDynamicToStatic()` も実装されており利用可能。

---



## O1 表示特例仕様（追加）
- O1 スロットは以下の条件で subslot 制御をランダマイザーが担当する。
  - O1 に `Slot_display_order` が複数存在する場合（例：What do you think it is? の分離構造）は subslot を生成せず、slot-mark のみを出力データに含める。
  - 上記でない場合は、他のスロット同様に subslot データを出力対象に含める。
- Structure 側はランダマイザーから受け取ったデータをそのまま描画する。
- この仕様により、特例例文と一般例文の親子スロット構造が両立する。

---

## 📚 **実装履歴・技術的課題の解決記録**

### **【2025年6月30日】Sスロット個別ランダマイズ機構実装**
- **目的**: 既存の全体ランダマイズ機能を壊さず、Sスロット（主語）のみを安全に個別ランダマイズ
- **技術的成果**: 上記の統合システム設計パターンの確立
- **学習成果**: スモールステップアプローチと既存システム理解の重要性を実証

### **【2025年7月4日】静的エリア同期システム完全リセット方式**
- **問題**: 母集団間で異なるサブスロット構造の場合、新しいサブスロットが表示されない
- **解決**: 完全リセット＋再構築方式の導入
- **技術的改善**: display_order による語順制御の実装

### **【2025年7月14日】データフロー設計真実の解明**
- **発見**: insert_test_data_clean.jsの二重機能（候補データ処理 + 動的エリア監視）
- **設計理念の明確化**: 柔軟性・効率性を重視したアーキテクチャの合理性を確認
- **仕様書の更新**: 実装と設計書の整合性確保

---

## 🎯 **音声システム連携に関する設計上の注意**

### **現在の問題点**
- **音声システムの参照先**: `window.lastSelectedSlots`（候補データ14個）を参照
- **実際の表示**: 動的記載エリア・静的スロット（実際の表示7個程度）
- **問題**: 音声が候補データ全体を読み上げ、実際の表示と不一致

### **推奨される修正方針**
- **音声データソース変更**: `window.lastSelectedSlots` → 実際の表示内容
- **参照先候補**: 動的記載エリアの内容または`window.currentDisplayedSentence`
- **修正対象**: `voice_system.js`のデータソース指定

### **設計一貫性の確保**
- 音声システムも「実際に表示されている内容」を参照することで、システム全体の一貫性を保つ
- 候補データではなく、確定した表示内容をユーザー体験の基準とする

---

## 🔄 **重複回避ランダマイズ最適化仕様（2025年7月16日実装）**

### **実装背景**
ユーザーエクスペリエンス向上のため、「ランダマイズボタンを押すと必ず異なる内容が表示される」ことを目指した重複回避システムを実装。

### **Phase 1: V_group_keyレベル重複回避**

#### **基本動作原理**
1. **現在状態の記録**: `window.currentRandomizedState.vGroupKey`で現在のV_group_keyを保存
2. **即座の重複回避**: 現在のV_group_keyを候補から除外
3. **履歴ベース回避**: `window.randomizeHistory`でN個前までの選択を記録し、重複を回避

#### **重複回避の段階的処理**
```javascript
// 段階1: 現在のV_group_keyを除外
let availableGroups = groups.filter(g => g !== window.currentRandomizedState.vGroupKey);

// 段階2: 履歴による重複回避
availableGroups = window.randomizeHistory.filterAvoidDuplicates(
  availableGroups, 
  window.currentRandomizedState?.vGroupKey, 
  'vGroupKeys'
);

// 段階3: 選択肢枯渇時の復活処理
if (availableGroups.length === 0) {
  console.log("🎯 重複回避後に選択肢がなくなったため、全候補を復活");
  availableGroups = groups;
}
```

#### **履歴管理システム**
- **保存場所**: `localStorage`（ブラウザ閉じても持続）
- **保存内容**: 
  - `vGroupKeys`: 過去N個のV_group_key履歴
  - `exampleIds`: 過去N個の例文ID履歴
- **履歴サイズ**: デフォルト10件（設定可能）
- **デバッグ機能**: `debugRandomizeAvoidance()`で現在の履歴状況を確認可能

#### **重複回避の優先順位**
1. **最優先**: 直前のV_group_keyを避ける
2. **次**: 履歴に記録された過去N個のV_group_keyを避ける
3. **最終**: 選択肢が枯渇した場合は全候補を復活

### **実装における技術的特徴**

#### **データフロー**
```
全体ランダマイズ実行
├─ V_group_key重複回避選択 (randomizer_all.js)
├─ 状態保存 (window.currentRandomizedState)
├─ 履歴保存 (window.randomizeHistory)
└─ 通常の表示処理継続
```

#### **安全性設計**
- **既存機能保護**: 従来のランダマイズロジックを完全に保持
- **段階的フォールバック**: 重複回避 → 履歴回避 → 全候補復活
- **エラーハンドリング**: LocalStorage失敗時でも基本機能は動作

#### **デバッグ支援**
- **詳細ログ**: 各段階でのフィルタリング状況を記録
- **デバッグ関数**: `debugRandomizeAvoidance()`で状態確認
- **履歴確認**: `window.randomizeHistory.load()`で履歴内容を確認

### **制限事項と今後の拡張可能性**

#### **現在の制限**
- **V_group_keyレベルのみ**: 同じV_group_key内での例文重複は回避されない
- **選択肢枯渇時**: 全候補復活により、短期間での重複が発生する可能性

#### **Phase 2 拡張案（未実装）**
- **例文IDレベル重複回避**: 同じV_group_key内でも異なる例文を選択
- **スロットレベル重複回避**: 個別スロットでの重複回避
- **複合条件回避**: V_group_key + 例文ID + 特定スロットの組み合わせ回避

### **運用上の注意事項**
- **履歴クリア**: `window.randomizeHistory.clear()`で履歴リセット可能
- **履歴サイズ調整**: 大きすぎると選択肢が枯渇しやすい
- **デバッグモード**: 開発時は`debugRandomizeAvoidance()`で動作確認推奨

### **ユーザーエクスペリエンス向上効果**
- **体感改善**: 連続同一表示の大幅減少
- **学習効率**: 多様な例文に効率的に触れられる
- **操作感向上**: 「ランダマイズボタンが必ず変化をもたらす」という期待に応える

---

*この設計仕様書は、実装検証に基づく正確な情報を記載しており、今後の開発・保守・機能拡張の基準文書として活用される。*
